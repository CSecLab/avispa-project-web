%% PROTOCOL: TLS: Transport Layer Security
%% PURPOSE:
%% TLS is intended to provide privacy and data integrity of communication
%% over the Internet.
%% REFERENCE:
%% \begin{itemize}
%% \item \cite{RFC2246,Paulson99}
%% \end{itemize}
%% MODELER:
%% \begin{itemize}
%% \item Paul Hankes Drielsma, ETH Z\"urich, November 2003
%%\end{itemize}
%% ALICE_BOB:
%% The protocol proceeds between a client \verb|A| and a 
%% server \verb|B| with respective public keys Ka and Kb.  
%% These two agents generate nonces \verb|Na|
%% and \verb|Nb|, respectively.  In addition, we assume the existence 
%% of a trusted third party (in essence, a certificate authority)
%% \verb|S| whose public key is \verb|Ks|.  The agents possess certificates
%% of the form \verb|{X,Kx}inv(Ks)|. Each session is identified by a unique 
%% ID \verb|Sid|.  The protocol also makes use of a pseudo-random number
%% generator PRF which we model as a hash function.
%%\begin{verbatim}
%% 0. A -> B: A, Na, Sid, Pa	       	where Pa is a cryptosuite offer
%% 1. B -> A: Nb, Sid, Pb		where Pb is B's counteroffer
%% 2. B -> A: {B, Kb}inv(Ks)		optional certificate exchange
%% 3. A -> B: {A, Ka}inv(Ks)		optional certificate exchange
%% 4. A -> B: {PMS}Kb			where PMS is a nonce generated by A
%% 5. A -> B: {H(Nb,B,PMS)}inv(Ka)	optional certificate verify message
%% 6. A -> B: {Finished}Keygen(A, Na, Nb, M) 
%% 		where 	M = PRF(PMS,Na,Nb)
%%			Finished = H(M,messages) for all messages 0 - 5
%% 7. B -> A: {Finished}Keygen(B, Na, Nb, M)
%%\end{verbatim}
%% Note that Paulson leaves messages 2., 3., and 5. as optional.  We
%% include them in this model.  Note also that in order to minimize
%% the number of transitions specified, we have combined the sending
%% of messages 1. and 2. as well as the sending of messages 
%% 3. 4. 5. and 6. into single transitions.
%%
%% LIMITATIONS:
%%
%% This formalisation is based on the abstracted version of TLS 
%% presented by Paulson in~\cite{Paulson99}.  In addition to the
%% abstractions made in this paper, we further abstract away
%% from the negotiation of cryptographic algorithms.  Our model
%% assumes that one offer for a crypto suite is made and only
%% that offer will be accepted. This may exclude cipher-suite 
%% rollback attacks like the one that was possible on SSLv2 and
%% implies that we assume goal G11 is fulfilled.
%%
%% PROBLEMS: 3
%% CLASSIFICATION: G1, G2, G3, G7, G10, G11, G13
%% ATTACKS: None
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%HLPSL:*
role cardholder(     C,M,P: agent, H : function,
                   KpubC,  KpubM,  KpubP : public_key,
     	             SND RCV: channel (dy) 
                        )
 played_by C def=
local S : nat,IC,IP2 : message,  % IP2 = IP + h (IC) + SD 
           Resp_pay : message,
           K1, K2,K4 : symmetric_key
init S := 0
transition
% =|> Purchase Request
1. S = 0 
/\       RCV(start) 
   =|>
   S' := 2 
 K1' := new() 
/\       K2' := new() 
/\       IP2' := new() 
/\      IC' := new() 
/\       SND (
	{IP2'}_K1'.{K1'}_KpubP.{IC'}_K2'.{K2'}_KpubM.
	 {H( {IP2'}_K1'.{K1'}_KpubP.{IC'}_K2'.{K2'}_KpubM)}_inv(KpubC)
            )
  
 /\      secret(IC',order,{C,M,P}) 	
 /\      secret(IP2',payment,{C,P}) 	
 /\      secret(K1',k1,{C,M}) 		
 /\      secret(K2',k2,{C,M}) 	
% Purchase Response =|>
1.	    S =  2
% retransmission de la reponse de la passerelle vers le client (par le marchand) 
/\        RCV   	( 	{Resp_pay'}_K4'.{K4' }_KpubC.	{H({Resp_pay'}_K4'.{K4'}_KpubM)}_inv(KpubP)
		%%on doit envoyer la sig de M??
	)
   =|>
   S' := 4
end role
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%2.Marchand
role merchant (C,M,P: agent, H : function,
               KpubC,  KpubM,  KpubP : public_key,
               SMC,RMC,SMP, RMP: channel (dy)
                )
 played_by M def=
 local S : nat,
       IC,IP2,Card_M : message,
       Resp_pay : message,
       K1 : symmetric_key,
       K2 : symmetric_key,
       K3 : symmetric_key,
       K4 : symmetric_key 
 init S := 1
 transition
 % Purchase Request =|> Payment  Request
1.        S = 1
 /\    RMC  (
	{IP2'}_K1'.{K1'}_KpubP.{IC'}_K2'.{K2'}_KpubM.
	 {H( {IP2'}_K1'.{K1'}_KpubP.{IC'}_K2'.{K2'}_KpubM)}_inv(KpubC)
            ) 
    =|>
       S' := 3
 /\    K3' := new()
 /\ Card_M' := new()
 /\    SMP ( {IP2'}_K1'.{K1'}_KpubP.{IC'}_K2'.{K2'}_KpubM.
          {H({IP2'}_K1'.{K1'}_KpubP.{IC'}_K2'.{K2'}_KpubM)}_inv(KpubC).  
                    {IC'.Card_M'}_K3'.{K3'}_KpubP.
                    {H({IC'.Card_M'}_K3'.{K3'}_KpubP)}_inv(KpubM)
                 )
  /\   secret(IC',order,{C,M,P}) 
  /\   secret(IP2',payment,{C,P}) 	
  /\   secret(K1',k1,{C,P}) 		
  /\   secret(K2',k2,{C,M}) 
  /\   secret(K3',k3,{M,P}) 
  /\   secret(Card_M',card_m,{M,P}) 
 % Payment Response =|> Response to Client
2.   S = 3/\
    RMP  (
	{Resp_pay'}_K4'.{K4'}_KpubM.
	{H({Resp_pay'}_K4'.{K4'}_KpubM)}_inv(KpubP)             )
    =|>
    S' := 5
/\    SMC  (
	{Resp_pay'}_K4'.{K4'}_KpubC.
	{H({Resp_pay'}_K4'.{K4'}_KpubM)}_inv(KpubP)  %%signature de P seulement
                ) 
/\   secret(Resp_pay',resp_pay,{C,M})
/\   secret(K4',k4,{C,M})
end role
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%3.Payment Gatway
role paymentgateway   (	C,M,P: agent,H : function,
KpubC,  KpubM,  KpubP : public_key,
                        SND, RCV: channel (dy) 
               	     ) 
	played_by P
 def=
local S : 	nat,
       	IC,IP2,Card_M : message,
	Resp_pay : message,
       	K1 : symmetric_key,
       	K2 : symmetric_key,
       	K3 : symmetric_key,
	K4 : symmetric_key
 init S := 6
 transition
 % Payment Request =|> Payment  Response
1.	   S  =  6
/\    RCV (
	{IP2'}_K1'.{K1'}_KpubP.{IC'}_K2'.{K2'}_KpubM.
                    { H({IP2'}_K1'.{K1'}_KpubP.{IC'}_K2'.{K2'}_KpubM)}_inv(KpubC).  %signature du client (a envoyer?)
                    {IC'.Card_M'}_K3'.{K3'}_KpubP.
	{H({IC'.Card_M'}_K3'.{K3'}_KpubP)}_inv(KpubM)
       	) 
    =|>
      S' := 7 
/\    K4' := new()
/\    Resp_pay' := new()
/\    SND  ( 
                     {Resp_pay'}_K4'.{K4'}_KpubM.
	{H({Resp_pay'}_K4'.{K4'}_KpubM)}_inv(KpubP)  
               )
 /\   secret(K4',k4,{M,P}) 
/\   secret(Resp_pay',resp_pay,{M,P})  
end role
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%4.Session
role session(C,M,P: agent, H : function,KpubC,  KpubM,  KpubP :public_key ) def=
 local SCM, RCM, SMP, RMP: channel(dy)
 composition
 cardholder(C,M,P,H,KpubC,KpubM,KpubP,SCM,RCM) /\
  merchant  (C,M,P,H,KpubC,KpubM,KpubP,SCM,RCM,SMP,RMP) /\
  paymentgateway(C,M,P,H,KpubC,KpubM,KpubP,RMP,SMP)
end role
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


role session(A,B: agent,
	     Ka, Kb, Ks: public_key,
	     H, PRF, KeyGen: hash_func)
def=

   local  SA, SB, RA, RB: channel (dy)

   composition
		alice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)
	   /\	bob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)

end role

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

role environment()
def=

   const na_nb1, na_nb2 : protocol_id,
         h, prf, keygen : hash_func,
         a, b           : agent,
         ka, kb, ki, ks : public_key

   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki),
                          {i.ki}_(inv(ks)) }  

   composition
	session(a,b,ka,kb,ks,h,prf,keygen)
    /\	session(a,i,ka,ki,ks,h,prf,keygen)
    /\	session(i,b,ki,kb,ks,h,prf,keygen)

end role

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

goal

  secrecy_of sec_clientk,sec_serverk  % Addresses G7
  %Alice authenticates Bob on na_nb1
  authentication_on na_nb1  % Addresses G1, G2, G3, G7, G10
  %Bob authenticates Alice on na_nb2
  authentication_on na_nb2  % Addresses G1, G2, G3, G7, G10

end goal

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

environment()
