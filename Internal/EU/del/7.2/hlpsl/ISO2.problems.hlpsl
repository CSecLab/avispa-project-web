%% DISCUSSION & ISSUES:
%% -----------
%% LucaC: 
%%
%% - I have corrected the protocol wrt HLPSL_GUIDELINES.
%%
%% - There was also an error in transition of role ISO2_Resp. 
%% 
%%   Rec(Rb',Text1') 
%% 
%%   has been replaced by 
%% 
%%   Rec(Rb'.Text1')
%%   
%%   If you leave Rec(Rb',Text1') the compiler compiles and neglects
%%   Text1' in the Rec channel. In my opinion the compiler should
%%   recognize this error.

%% 1-3-2  ISO2
%%%%% [ETHZ] Also known as "ISO (Public Key) Two-Pass Unilateral Authentication Protocol" ClarkJacob 6.6.2

%% A-B Notation:

%% 1. B --> A : Rb, Text1

%% 2. A --> B : {PKa,A}SKc, Ra,Rb, B, Text2,{Ra,Rb,B,Text1}_SKa

%% SKc is the private key of the server C.
%% {PKa,A}SKc is the certificate of agent A

%%--------------------------Nhlpsl-spec ---------------------

role ISO2_Init (B,A    : agent,
                Pks    : public_key, 
                Snd,Rec: channel(dy)) played_by B def=

  exists State     : nat,
         Pka  	   : public_key,
         Rb   	   : text(fresh),
         Ra, Text2 : text

  owns Snd

  
  

  init State = 0

  knowledge(B)={A,B,ctext1,Pks}

  transition

   1. State=0 /\ Rec(start) =|> Snd(Rb'.ctext1) /\ State'=1 			%% /\ witness(B,A,rb,Rb')

   2.    State=1
      /\ Rec(Pka'.A.{Pka'.A}inv(Pks).Ra'.Rb.B.Text2'.{Ra'.Rb.B.ctext1}inv(Pka'))  
      =|> 
         State'=2 
      /\ request(B,A,ra,Ra')

end role

%%  (*------------------------------------------------------*)

role ISO2_Resp (A,B    : agent,
                Pka,Pks: public_key,
                Snd,Rec: channel(dy)) played_by A def=

  exists State     : nat,
         Ra	   : text(fresh),
         Rb, Text1 : text

  owns Snd



  init State = 0

  knowledge(A)={A,B,Pka,Pks,ctext2,inv(Pka)}

  transition

   1. State=0 /\ Rec(Rb'.Text1') =|> 
         Snd(Pka.A.{Pka.A}inv(Pks).Ra'.Rb'.B.ctext2.{Ra'.Rb'.B.Text1'}inv(Pka))
      /\ State'=2 
      /\ witness(A,B,ra,Ra')


end role

%% LC: if you would like to use the same server public key for each
%%     session, you should avoid permutation on Pks.

role Session (B, A : agent,
	      Pka  : public_key,
              Pks  : public_key,
	      SA, RA, SB, RB: channel (dy)) def=

  composition

          ISO2_Init(B,A,Pks,SB,RB)
       /\ ISO2_Resp(A,B,Pka,Pks,SA,RA)

end role

%%  (*------------------------------------------------------*)


role Environment() def=

  const  ctext1,ctext2 : text,
	 rb,ra	       : protocol_id
  
%%  knowledge(i)={a,b,c,pks,pki,inv(pki)}
  knowledge(i)={a,b,pks,pki,inv(pki)}

  composition

	Session(a,b,pkb,pks,sa1,ra1,sb1,rb1)
     /\	Session(a,i,pki,pks,sa2,ra2,si2,ri2)
     /\	Session(i,b,pkb,pks,si3,ri3,sb3,rb3)

%%   composition
%% 
%% 	Session(a,b,pkb,pks,sa1,ra1,sb1,rb1)
%%      /\	Session(a,c,pkc,pks,sa2,ra2,sc2,rc2)
%%      /\	Session(a,a,pka,pks,sa3,ra3,sa3,ra3)
%%      /\	Session(b,a,pka,pks,sb4,rb4,sa4,ra4)

end role

%%  (*------------------------------------------------------*)

goal

%% LC: I do not see any reason to make authentication on Rb that is
%%     generated by the initiator. Hence I have changed it.
%% Init. authenticates Resp. on Ra,Rb

   ISO2_Init  authenticates ISO2_Resp on Ra

end goal

%%  (*------------------------------------------------------*)


Environment()

